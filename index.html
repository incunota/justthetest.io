<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Playground de Física com Objetos Atacantes (PvP)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
    }

    #container {
      position: relative;
      width: 800px;
      height: 600px;
    }

    #canvas {
      background-color: #333;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: transparent;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      color: black;
      pointer-events: none;
    }

    #controls p {
      margin: 5px 0;
      text-shadow: 0 0 2px white;
    }

    #controls strong {
      text-shadow: 0 0 3px white;
    }

    #speed-display {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
    }

    .hamburger-icon {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      cursor: pointer;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 6px;
    }

    .hamburger-icon::before,
    .hamburger-icon::after,
    .hamburger-icon span {
      content: '';
      display: block;
      width: 24px;
      height: 3px;
      background-color: white;
      border-radius: 3px;
    }

    #settings-menu {
      position: absolute;
      bottom: 60px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      color: white;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
      width: 220px;
      max-height: 400px;
      overflow-y: auto;
    }

    #settings-menu.hidden {
      display: none;
    }

    #settings-menu label {
      display: flex;
      flex-direction: column;
    }

    /* Estilo para a barra de vida */
    .health-bar {
      position: absolute;
      width: 40px;
      height: 4px;
      background-color: #333;
      border: 1px solid #555;
      border-radius: 2px;
      z-index: 5;
    }

    .health-fill {
      height: 100%;
      background-color: #4CAF50;
      border-radius: 1px;
      transition: width 0.3s;
    }

    /* Indicador de objeto atacante */
    .attacker-indicator {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      z-index: 5;
    }

    /* Estilo para diferentes times */
    .team-red {
      background-color: #FF4444;
    }

    .team-blue {
      background-color: #4444FF;
    }

    .team-green {
      background-color: #44FF44;
    }

    .team-yellow {
      background-color: #FFFF44;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas" width="800" height="600"></canvas>

    <div id="controls">
      <p><strong>Controles:</strong></p>
      <p>E = Criar bola</p>
      <p>H = Criar quadrado</p>
      <p>K = Criar triângulo</p>
      <p>S = Girar objeto (segure para aumentar velocidade)</p>
      <p>B = Buraco negro (segure para ativar)</p>
      <p>M = Criar bola atacante (Time Vermelho)</p>
      <p>N = Criar quadrado atacante (Time Azul)</p>
      <p>L = Criar triângulo atacante (Time Verde)</p>
      <p>P = Criar bola atacante (Time Amarelo)</p>
      <p>O = Criar quadrado atacante (Time Amarelo)</p>
      <p>I = Criar triângulo atacante (Time Amarelo)</p>
      <p>Arraste com mouse para mover</p>
    </div>

    <div id="speed-display">Velocidade: 0</div>

    <div id="gear-icon" class="hamburger-icon">
      <span></span>
    </div>
    <div id="settings-menu" class="hidden">
      <label>Força do buraco negro: <input type="range" id="force-slider" min="0.0001" max="0.01" step="0.0001" value="0.001"></label>
      <label>Alcance: <input type="range" id="range-slider" min="50" max="800" step="10" value="300"></label>
      <label>Tamanho do buraco negro: <input type="range" id="size-slider" min="10" max="200" step="5" value="30"></label>
      <label>Velocidade inicial de giro: <input type="number" id="spin-start" min="1" max="1000" step="1" value="20"></label>
      <label>Nível de saltitante: <input type="range" id="bounciness" min="0" max="1" step="0.1" value="0.7"></label>
      <label>Chão escorregadio: <input type="range" id="floor-friction" min="0" max="1" step="0.1" value="0"></label>
      <label>Gravidade: <input type="range" id="gravity-slider" min="0" max="1" step="0.1" value="0"></label>
      <label>Fazer objetos atacantes seguirem: <input type="checkbox" id="attacker-follow"></label>
      <label>Dano por contato: <input type="number" id="damage-value" min="1" max="100" step="1" value="10"></label>
      <label>Vida máxima dos objetos: <input type="number" id="max-health" min="1" max="100" step="1" value="100"></label>
      <label>Modo PvP (atacantes se atacam): <input type="checkbox" id="pvp-mode" checked></label>
      <label>Sistema de times: <input type="checkbox" id="team-system" checked></label>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
  <script>
    const { Engine, Render, World, Bodies, Body, Mouse, MouseConstraint, Events, Composite, Vertices } = Matter;

    const initialGravity = { x: 0, y: 0.5 };
    const engine = Engine.create({ gravity: initialGravity, enableSleeping: true });
    const canvas = document.getElementById('canvas');

    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: 800,
        height: 600,
        wireframes: false,
        background: '#333',
        showAngleIndicator: true
      }
    });

    const colors = ['#FF5733', '#33FF57', '#3357FF', '#F3FF33', '#FF33F3', '#FF8C33'];
    const teamColors = ['#FF4444', '#4444FF', '#44FF44', '#FFFF44'];
    const teamNames = ['red', 'blue', 'green', 'yellow'];
    
    let selectedBody = null;
    let currentSpeed = 0;
    let targetSpeed = 0;
    let isSpinKeyPressed = false;
    let speedIncrementTimer = null;
    let initialSpeed = 20;
    const spinIncrement = 5;
    const speedDisplay = document.getElementById('speed-display');
    let blackHole = null;
    let isBlackHoleActive = false;
    let blackHoleForce = 0.001;
    let blackHoleRange = 300;
    let blackHoleSize = 30;
    let bounciness = 0.7;
    let floorFriction = 0;
    let ground = null;
    let gravityValue = 0;
    let attackersFollow = false;
    let damageValue = 10;
    let maxHealth = 100;
    let pvpMode = true;
    let teamSystem = true;

    // Objetos atacantes
    const attackers = [];
    const healthBars = {};
    const attackerIndicators = {};

    // Configurações iniciais
    document.getElementById('attacker-follow').addEventListener('change', function(e) {
      attackersFollow = e.target.checked;
    });
    
    document.getElementById('damage-value').addEventListener('input', function(e) {
      damageValue = parseInt(e.target.value);
    });
    
    document.getElementById('max-health').addEventListener('input', function(e) {
      maxHealth = parseInt(e.target.value);
    });
    
    document.getElementById('pvp-mode').addEventListener('change', function(e) {
      pvpMode = e.target.checked;
    });
    
    document.getElementById('team-system').addEventListener('change', function(e) {
      teamSystem = e.target.checked;
    });

    function updateSpeedDisplay() {
      speedDisplay.textContent = `Velocidade: ${Math.round(currentSpeed)}`;
    }

    function updateGravity(value) {
      const gravityStrength = initialGravity.y * (1 - value);
      engine.gravity.y = gravityStrength;
      
      const bodies = Composite.allBodies(engine.world);
      bodies.forEach(body => {
        if (!body.isStatic) {
          Body.set(body, {
            frictionAir: value === 1 ? 0 : 0.02
          });
        }
      });
    }

    function createInitialObjects() {
      const wallOptions = { isStatic: true, render: { fillStyle: '#444', strokeStyle: '#555' } };
      ground = Bodies.rectangle(400, 590, 810, 20, { 
        ...wallOptions,
        restitution: bounciness,
        friction: 1 - floorFriction
      });
      const leftWall = Bodies.rectangle(10, 300, 20, 600, wallOptions);
      const rightWall = Bodies.rectangle(790, 300, 20, 600, wallOptions);
      const ceiling = Bodies.rectangle(400, 10, 810, 20, wallOptions);
      World.add(engine.world, [ground, leftWall, rightWall, ceiling]);
    }

    function createBall(x, y, isAttacker = false, teamIndex = 0) {
      const radius = 15 + Math.random() * 15;
      const ball = Bodies.circle(x || Math.random() * 700 + 50, y || Math.random() * 400 + 50, radius, {
        restitution: bounciness,
        friction: 0.1,
        frictionAir: gravityValue === 1 ? 0 : 0.02,
        density: 0.05,
        render: { 
          fillStyle: isAttacker ? teamColors[teamIndex] : colors[Math.floor(Math.random() * colors.length)], 
          strokeStyle: '#000', 
          lineWidth: 1 
        }
      });
      
      World.add(engine.world, ball);
      
      // Adicionar barra de vida
      addHealthBar(ball.id, ball.position.x, ball.position.y - radius - 10);
      
      // Se for atacante, adicionar indicador e registrar
      if (isAttacker) {
        addAttackerIndicator(ball.id, ball.position.x, ball.position.y - radius - 20, teamIndex);
        attackers.push({
          body: ball,
          type: 'ball',
          team: teamIndex,
          target: null,
          lastAttackTime: 0,
          attackCooldown: 1000 // 1 segundo de cooldown entre ataques
        });
      }
      
      return ball;
    }

    function createBox(x, y, isAttacker = false, teamIndex = 0) {
      const size = 20 + Math.random() * 30;
      const box = Bodies.rectangle(x || Math.random() * 700 + 50, y || Math.random() * 400 + 50, size, size, {
        restitution: bounciness,
        friction: 0.2,
        frictionAir: gravityValue === 1 ? 0 : 0.02,
        density: 0.1,
        render: { 
          fillStyle: isAttacker ? teamColors[teamIndex] : colors[Math.floor(Math.random() * colors.length)], 
          strokeStyle: '#000', 
          lineWidth: 1 
        }
      });
      
      World.add(engine.world, box);
      
      // Adicionar barra de vida
      addHealthBar(box.id, box.position.x, box.position.y - size/2 - 10);
      
      // Se for atacante, adicionar indicador e registrar
      if (isAttacker) {
        addAttackerIndicator(box.id, box.position.x, box.position.y - size/2 - 20, teamIndex);
        attackers.push({
          body: box,
          type: 'box',
          team: teamIndex,
          target: null,
          lastAttackTime: 0,
          attackCooldown: 1000 // 1 segundo de cooldown entre ataques
        });
      }
      
      return box;
    }

    function createTriangle(x, y, isAttacker = false, teamIndex = 0) {
      const size = 20 + Math.random() * 20;
      const triangle = Bodies.fromVertices(
        x || 400,
        y || 300,
        [[{ x: 0, y: -size }, { x: size, y: size }, { x: -size, y: size }]],
        {
          restitution: bounciness,
          frictionAir: gravityValue === 1 ? 0 : 0.02,
          density: 0.05,
          render: { 
            fillStyle: isAttacker ? teamColors[teamIndex] : colors[Math.floor(Math.random() * colors.length)], 
            strokeStyle: '#000', 
            lineWidth: 1 
          }
        },
        true
      );
      
      World.add(engine.world, triangle);
      
      // Adicionar barra de vida
      addHealthBar(triangle.id, triangle.position.x, triangle.position.y - size - 10);
      
      // Se for atacante, adicionar indicador e registrar
      if (isAttacker) {
        addAttackerIndicator(triangle.id, triangle.position.x, triangle.position.y - size - 20, teamIndex);
        attackers.push({
          body: triangle,
          type: 'triangle',
          team: teamIndex,
          target: null,
          lastAttackTime: 0,
          attackCooldown: 1000 // 1 segundo de cooldown entre ataques
        });
      }
      
      return triangle;
    }

    function addHealthBar(bodyId, x, y) {
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      healthBar.id = `health-${bodyId}`;
      healthBar.style.left = `${x - 20}px`;
      healthBar.style.top = `${y}px`;
      
      const healthFill = document.createElement('div');
      healthFill.className = 'health-fill';
      healthFill.style.width = '100%';
      healthFill.id = `health-fill-${bodyId}`;
      
      healthBar.appendChild(healthFill);
      document.getElementById('container').appendChild(healthBar);
      
      healthBars[bodyId] = {
        element: healthBar,
        fill: healthFill,
        health: maxHealth
      };
    }

    function addAttackerIndicator(bodyId, x, y, teamIndex) {
      const indicator = document.createElement('div');
      indicator.className = `attacker-indicator team-${teamNames[teamIndex]}`;
      indicator.id = `indicator-${bodyId}`;
      indicator.style.left = `${x - 5}px`;
      indicator.style.top = `${y}px`;
      
      document.getElementById('container').appendChild(indicator);
      attackerIndicators[bodyId] = indicator;
    }

    function updateHealthBar(bodyId, damage) {
      if (healthBars[bodyId]) {
        healthBars[bodyId].health -= damage;
        const healthPercent = (healthBars[bodyId].health / maxHealth) * 100;
        healthBars[bodyId].fill.style.width = `${healthPercent}%`;
        
        // Mudar cor conforme a vida diminui
        if (healthPercent > 60) {
          healthBars[bodyId].fill.style.backgroundColor = '#4CAF50'; // Verde
        } else if (healthPercent > 30) {
          healthBars[bodyId].fill.style.backgroundColor = '#FFC107'; // Amarelo
        } else {
          healthBars[bodyId].fill.style.backgroundColor = '#F44336'; // Vermelho
        }
        
        // Se a vida chegar a zero, remover o objeto
        if (healthBars[bodyId].health <= 0) {
          const body = Composite.allBodies(engine.world).find(b => b.id === bodyId);
          if (body) {
            World.remove(engine.world, body);
            
            // Remover do array de atacantes
            const attackerIndex = attackers.findIndex(a => a.body.id === bodyId);
            if (attackerIndex !== -1) {
              attackers.splice(attackerIndex, 1);
            }
          }
          
          // Remover a barra de vida
          healthBars[bodyId].element.remove();
          delete healthBars[bodyId];
          
          // Remover indicador se existir
          if (attackerIndicators[bodyId]) {
            attackerIndicators[bodyId].remove();
            delete attackerIndicators[bodyId];
          }
        }
      }
    }

    function updateHealthBarPosition(bodyId, x, y) {
      if (healthBars[bodyId]) {
        const body = Composite.allBodies(engine.world).find(b => b.id === bodyId);
        if (body) {
          let offsetY = 0;
          
          if (body.circleRadius) {
            offsetY = body.circleRadius + 10;
          } else if (body.vertices) {
            // Para triângulos e outras formas
            const bounds = Matter.Bounds.create(body.vertices);
            offsetY = (bounds.max.y - bounds.min.y) / 2 + 10;
          } else {
            // Para retângulos
            offsetY = body.bounds.max.y - body.bounds.min.y + 10;
          }
          
          healthBars[bodyId].element.style.left = `${x - 20}px`;
          healthBars[bodyId].element.style.top = `${y - offsetY}px`;
        }
      }
      
      // Atualizar também o indicador de atacante
      if (attackerIndicators[bodyId]) {
        const body = Composite.allBodies(engine.world).find(b => b.id === bodyId);
        if (body) {
          let offsetY = 0;
          
          if (body.circleRadius) {
            offsetY = body.circleRadius + 20;
          } else if (body.vertices) {
            const bounds = Matter.Bounds.create(body.vertices);
            offsetY = (bounds.max.y - bounds.min.y) / 2 + 20;
          } else {
            offsetY = body.bounds.max.y - body.bounds.min.y + 20;
          }
          
          attackerIndicators[bodyId].style.left = `${x - 5}px`;
          attackerIndicators[bodyId].style.top = `${y - offsetY}px`;
        }
      }
    }

    function createBlackHole(x, y) {
      blackHole = Bodies.circle(x, y, blackHoleSize, {
        isStatic: true,
        isSensor: true,
        render: { fillStyle: '#000', strokeStyle: '#fff', lineWidth: 2 }
      });
      World.add(engine.world, blackHole);
    }

    function applyBlackHoleForce() {
      if (!blackHole) return;
      const bodies = Composite.allBodies(engine.world);
      bodies.forEach(body => {
        if (body === blackHole || body.isStatic) return;

        const dx = blackHole.position.x - body.position.x;
        const dy = blackHole.position.y - body.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < blackHoleRange) {
          const forceMagnitude = blackHoleForce * body.mass;
          const force = {
            x: dx / distance * forceMagnitude,
            y: dy / distance * forceMagnitude
          };
          Body.applyForce(body, body.position, force);
        }

        if (distance < blackHoleSize) {
          World.remove(engine.world, body);
          
          // Remover também a barra de vida
          if (healthBars[body.id]) {
            healthBars[body.id].element.remove();
            delete healthBars[body.id];
          }
          
          // Remover indicador se existir
          if (attackerIndicators[body.id]) {
            attackerIndicators[body.id].remove();
            delete attackerIndicators[body.id];
          }
        }
      });
    }

    function startSpeedIncrement() {
      if (speedIncrementTimer) return;
      targetSpeed = initialSpeed;
      currentSpeed = initialSpeed;
      updateSpeedDisplay();
      speedIncrementTimer = setInterval(() => { targetSpeed += spinIncrement; }, 1000);
    }

    function stopSpeedIncrement() {
      if (speedIncrementTimer) {
        clearInterval(speedIncrementTimer);
        speedIncrementTimer = null;
      }
      targetSpeed = 0;
      currentSpeed = 0;
      updateSpeedDisplay();
    }

    function applySpin() {
      if (!selectedBody || !isSpinKeyPressed) {
        return;
      }
      
      const smoothingFactor = 0.1;
      currentSpeed += (targetSpeed - currentSpeed) * smoothingFactor;
      const angularSpeed = currentSpeed * (Math.PI / 180);
      Body.setAngularVelocity(selectedBody, angularSpeed);
      updateSpeedDisplay();
    }

    function setupMouseInteraction() {
      const mouse = Mouse.create(canvas);
      const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: { stiffness: 0.2, render: { visible: false } }
      });
      World.add(engine.world, mouseConstraint);
      Events.on(mouseConstraint, 'startdrag', function(event) {
        selectedBody = event.body;
        if (isSpinKeyPressed) {
          startSpeedIncrement();
        }
      });
      Events.on(mouseConstraint, 'enddrag', function(event) {
        // Não faz nada ao soltar - o objeto mantém seu estado
      });
      render.mouse = mouse;
    }

    function setupKeyboardControls() {
      document.addEventListener('keydown', function(event) {
        const mousePosition = render.mouse?.position || { x: 400, y: 300 };
        switch (event.key.toLowerCase()) {
          case 'e': createBall(mousePosition.x, mousePosition.y); break;
          case 'h': createBox(mousePosition.x, mousePosition.y); break;
          case 'k': createTriangle(mousePosition.x, mousePosition.y); break;
          case 'm': createBall(mousePosition.x, mousePosition.y, true, 0); break; // Time Vermelho
          case 'n': createBox(mousePosition.x, mousePosition.y, true, 1); break;  // Time Azul
          case 'l': createTriangle(mousePosition.x, mousePosition.y, true, 2); break; // Time Verde
          case 'p': createBall(mousePosition.x, mousePosition.y, true, 3); break; // Time Amarelo
          case 'o': createBox(mousePosition.x, mousePosition.y, true, 3); break;  // Time Amarelo
          case 'i': createTriangle(mousePosition.x, mousePosition.y, true, 3); break; // Time Amarelo
          case 's':
            if (!isSpinKeyPressed) {
              isSpinKeyPressed = true;
              if (selectedBody) {
                startSpeedIncrement();
              }
            }
            break;
          case 'b':
            if (!isBlackHoleActive) {
              isBlackHoleActive = true;
              createBlackHole(mousePosition.x, mousePosition.y);
            }
            break;
        }
      });

      document.addEventListener('keyup', function(event) {
        switch (event.key.toLowerCase()) {
          case 's':
            isSpinKeyPressed = false;
            stopSpeedIncrement();
            if (selectedBody) {
              Body.setAngularVelocity(selectedBody, 0);
            }
            break;
          case 'b':
            isBlackHoleActive = false;
            if (blackHole) {
              World.remove(engine.world, blackHole);
              blackHole = null;
            }
            break;
        }
      });
    }

    function updatePhysicsParameters() {
      if (ground) {
        Body.set(ground, {
          restitution: bounciness,
          friction: 1 - floorFriction
        });
      }
      
      const bodies = Composite.allBodies(engine.world);
      bodies.forEach(body => {
        if (body.isStatic) return;
        Body.set(body, {
          restitution: bounciness,
          frictionAir: gravityValue === 1 ? 0 : 0.02
        });
      });
    }

    // Detectar colisões e aplicar dano
    function setupCollisionDetection() {
      Events.on(engine, 'collisionStart', function(event) {
        const pairs = event.pairs;
        
        for (let i = 0; i < pairs.length; i++) {
          const pair = pairs[i];
          const bodyA = pair.bodyA;
          const bodyB = pair.bodyB;
          
          // Verificar se um dos corpos é um atacante
          const attackerA = attackers.find(a => a.body.id === bodyA.id);
          const attackerB = attackers.find(a => a.body.id === bodyB.id);
          
          // Aplicar dano se um dos corpos for atacante
          if (attackerA) {
            // Verificar se pode atacar (cooldown)
            const now = Date.now();
            if (now - attackerA.lastAttackTime > attackerA.attackCooldown) {
              // Verificar se o alvo é válido
              let canAttack = false;
              
              if (attackerB) {
                // Ambos são atacantes - verificar se podem se atacar
                if (pvpMode) {
                  if (teamSystem) {
                    // Com sistema de times: só atacar se forem de times diferentes
                    canAttack = attackerA.team !== attackerB.team;
                  } else {
                    // Sem sistema de times: sempre podem se atacar
                    canAttack = true;
                  }
                }
              } else {
                // Atacante vs objeto normal - sempre pode atacar
                canAttack = true;
              }
              
              if (canAttack) {
                attackerA.lastAttackTime = now;
                updateHealthBar(bodyB.id, damageValue);
                
                // Aplicar uma pequena força para simular o impacto
                const force = {
                  x: (bodyB.position.x - bodyA.position.x) * 0.01,
                  y: (bodyB.position.y - bodyA.position.y) * 0.01
                };
                Body.applyForce(bodyB, bodyB.position, force);
              }
            }
          }
          
          // Verificar o outro corpo também
          if (attackerB) {
            // Verificar se pode atacar (cooldown)
            const now = Date.now();
            if (now - attackerB.lastAttackTime > attackerB.attackCooldown) {
              // Verificar se o alvo é válido
              let canAttack = false;
              
              if (attackerA) {
                // Ambos são atacantes - verificar se podem se atacar
                if (pvpMode) {
                  if (teamSystem) {
                    // Com sistema de times: só atacar se forem de times diferentes
                    canAttack = attackerB.team !== attackerA.team;
                  } else {
                    // Sem sistema de times: sempre podem se atacar
                    canAttack = true;
                  }
                }
              } else {
                // Atacante vs objeto normal - sempre pode atacar
                canAttack = true;
              }
              
              if (canAttack) {
                attackerB.lastAttackTime = now;
                updateHealthBar(bodyA.id, damageValue);
                
                // Aplicar uma pequena força para simular o impacto
                const force = {
                  x: (bodyA.position.x - bodyB.position.x) * 0.01,
                  y: (bodyA.position.y - bodyB.position.y) * 0.01
                };
                Body.applyForce(bodyA, bodyA.position, force);
              }
            }
          }
        }
      });
    }

    // Lógica para os atacantes seguirem outros objetos
    function updateAttackers() {
      attackers.forEach(attacker => {
        // Seguir outros objetos se a opção estiver ativada
        if (attackersFollow && !attacker.target) {
          // Encontrar um alvo válido
          const bodies = Composite.allBodies(engine.world);
          let closestTarget = null;
          let closestDistance = Infinity;
          
          bodies.forEach(body => {
            if (body !== attacker.body && !body.isStatic) {
              // Verificar se é um alvo válido
              const targetAttacker = attackers.find(a => a.body.id === body.id);
              let isValidTarget = false;
              
              if (targetAttacker) {
                // É um atacante - verificar se pode atacar
                if (pvpMode) {
                  if (teamSystem) {
                    isValidTarget = attacker.team !== targetAttacker.team;
                  } else {
                    isValidTarget = true;
                  }
                }
              } else {
                // É um objeto normal - sempre válido
                isValidTarget = true;
              }
              
              if (isValidTarget) {
                const dx = body.position.x - attacker.body.position.x;
                const dy = body.position.y - attacker.body.position.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestTarget = body;
                }
              }
            }
          });
          
          if (closestTarget && closestDistance < 200) { // Alcance de detecção
            attacker.target = closestTarget;
          }
        }
        
        // Mover em direção ao alvo
        if (attacker.target) {
          const dx = attacker.target.position.x - attacker.body.position.x;
          const dy = attacker.target.position.y - attacker.body.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 30) { // Parar a uma certa distância
            const force = {
              x: dx / distance * 0.005,
              y: dy / distance * 0.005
            };
            Body.applyForce(attacker.body, attacker.body.position, force);
          } else if (distance > 200) {
            // Se o alvo estiver muito longe, perder o rastreamento
            attacker.target = null;
          }
        }
      });
    }

    // Atualizar posições das barras de vida
    function updateHealthBarPositions() {
      const bodies = Composite.allBodies(engine.world);
      bodies.forEach(body => {
        if (healthBars[body.id]) {
          updateHealthBarPosition(body.id, body.position.x, body.position.y);
        }
      });
    }

    function customPhysics() {
      if (isSpinKeyPressed && selectedBody) {
        applySpin();
      }
      
      if (isBlackHoleActive && blackHole) applyBlackHoleForce();
      
      // Atualizar lógica dos atacantes
      updateAttackers();
      
      // Atualizar posições das barras de vida
      updateHealthBarPositions();
      
      requestAnimationFrame(customPhysics);
    }

    // Config menu listeners
    document.getElementById('gear-icon').addEventListener('click', () => {
      document.getElementById('settings-menu').classList.toggle('hidden');
    });

    document.getElementById('force-slider').addEventListener('input', (e) => {
      blackHoleForce = parseFloat(e.target.value);
    });

    document.getElementById('range-slider').addEventListener('input', (e) => {
      blackHoleRange = parseFloat(e.target.value);
    });

    document.getElementById('size-slider').addEventListener('input', (e) => {
      blackHoleSize = parseFloat(e.target.value);
    });

    document.getElementById('spin-start').addEventListener('input', (e) => {
      initialSpeed = parseFloat(e.target.value);
    });

    document.getElementById('bounciness').addEventListener('input', (e) => {
      bounciness = parseFloat(e.target.value);
      updatePhysicsParameters();
    });

    document.getElementById('floor-friction').addEventListener('input', (e) => {
      floorFriction = parseFloat(e.target.value);
      updatePhysicsParameters();
    });

    document.getElementById('gravity-slider').addEventListener('input', (e) => {
      gravityValue = parseFloat(e.target.value);
      updateGravity(gravityValue);
    });

    createInitialObjects();
    setupMouseInteraction();
    setupKeyboardControls();
    setupCollisionDetection();
    updateSpeedDisplay();
    for (let i = 0; i < 3; i++) {
      createBall();
      createBox();
    }
    Engine.run(engine);
    Render.run(render);
    customPhysics();
  </script>
</body>
</html>
